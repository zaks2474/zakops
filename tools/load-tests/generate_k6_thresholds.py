#!/usr/bin/env python3
"""Generate k6 thresholds from SLO configuration.

Reads SLO definitions and generates k6 threshold configuration
that can be used in load test scenarios.
"""

import json
import sys
from pathlib import Path

import yaml


def load_slo_config(path: Path) -> dict:
    """Load SLO configuration from YAML file.

    Args:
        path: Path to slo_config.yaml

    Returns:
        dict: SLO configuration
    """
    with open(path) as f:
        return yaml.safe_load(f)


def slo_to_k6_threshold(slo: dict) -> dict:
    """Convert a single SLO to k6 threshold format.

    Args:
        slo: SLO definition dict

    Returns:
        dict: k6 threshold configuration
    """
    slo_id = slo.get("id", "unknown")
    slo_type = slo.get("type")
    target = slo.get("target")
    percentile = slo.get("percentile")

    # Map SLO types to k6 metrics
    if slo_type == "latency":
        # k6 uses http_req_duration for latency
        metric = "http_req_duration"

        if percentile:
            # p95, p99 thresholds
            threshold_name = f"p({percentile})"
            threshold_value = f"p({percentile})<{target}"
        else:
            # Average latency
            threshold_name = "avg"
            threshold_value = f"avg<{target}"

        return {
            "slo_id": slo_id,
            "metric": metric,
            "threshold_name": threshold_name,
            "threshold_value": threshold_value,
            "target_ms": target,
            "description": slo.get("description", ""),
        }

    elif slo_type == "availability":
        # k6 uses http_req_failed rate for availability
        metric = "http_req_failed"
        # Convert availability % to failure rate
        # e.g., 99.5% availability = 0.5% failure rate = 0.005
        failure_rate = (100 - target) / 100

        return {
            "slo_id": slo_id,
            "metric": metric,
            "threshold_name": "rate",
            "threshold_value": f"rate<{failure_rate}",
            "target_pct": target,
            "description": slo.get("description", ""),
        }

    elif slo_type == "error_rate":
        # Error rate directly maps to http_req_failed
        metric = "http_req_failed"
        rate = target / 100

        return {
            "slo_id": slo_id,
            "metric": metric,
            "threshold_name": "rate",
            "threshold_value": f"rate<{rate}",
            "target_pct": target,
            "description": slo.get("description", ""),
        }

    elif slo_type == "accuracy":
        # Accuracy SLOs don't map directly to k6 metrics
        # They require golden trace evaluation
        return {
            "slo_id": slo_id,
            "metric": "custom",
            "threshold_name": "accuracy",
            "threshold_value": f"accuracy>={target}",
            "target_pct": target,
            "description": slo.get("description", ""),
            "notes": "Requires golden trace evaluation, not k6",
        }

    else:
        return {
            "slo_id": slo_id,
            "metric": "unknown",
            "threshold_name": "unknown",
            "threshold_value": "unknown",
            "notes": f"Unsupported SLO type: {slo_type}",
        }


def generate_k6_thresholds_js(thresholds: list) -> str:
    """Generate k6 thresholds JavaScript module.

    Args:
        thresholds: List of threshold configurations

    Returns:
        str: JavaScript module content
    """
    js_lines = [
        "// Auto-generated k6 thresholds from SLO configuration",
        "// Generated by: generate_k6_thresholds.py",
        f"// Generated at: {__import__('datetime').datetime.now().isoformat()}",
        "",
        "export const thresholds = {",
    ]

    # Group by metric
    by_metric = {}
    for t in thresholds:
        metric = t.get("metric")
        if metric and metric != "custom" and metric != "unknown":
            if metric not in by_metric:
                by_metric[metric] = []
            by_metric[metric].append(t["threshold_value"])

    for metric, values in by_metric.items():
        js_lines.append(f"  '{metric}': {json.dumps(values)},")

    js_lines.append("};")
    js_lines.append("")
    js_lines.append("// Threshold metadata for documentation")
    js_lines.append("export const thresholdMetadata = " + json.dumps(thresholds, indent=2) + ";")
    js_lines.append("")

    return "\n".join(js_lines)


def main():
    """Generate k6 thresholds from SLO config."""
    # Default paths
    project_root = Path(__file__).parent.parent.parent
    slo_config_path = project_root / "docs" / "slos" / "slo_config.yaml"
    output_dir = project_root / "tools" / "load-tests" / "generated"
    artifacts_dir = project_root / "artifacts" / "perf"

    # Ensure output directories exist
    output_dir.mkdir(parents=True, exist_ok=True)
    artifacts_dir.mkdir(parents=True, exist_ok=True)

    # Load SLO config
    if not slo_config_path.exists():
        print(f"Error: SLO config not found at {slo_config_path}")
        return 1

    slo_config = load_slo_config(slo_config_path)
    slos = slo_config.get("slos", [])

    if not slos:
        print("Error: No SLOs defined in config")
        return 1

    # Convert SLOs to thresholds
    thresholds = []
    for slo in slos:
        threshold = slo_to_k6_threshold(slo)
        thresholds.append(threshold)

    # Generate JavaScript module
    js_content = generate_k6_thresholds_js(thresholds)
    js_output_path = output_dir / "thresholds.js"
    with open(js_output_path, "w") as f:
        f.write(js_content)

    print(f"Generated: {js_output_path}")

    # Write JSON artifact
    artifact = {
        "generated_at": __import__("datetime").datetime.now().isoformat(),
        "source_file": str(slo_config_path),
        "thresholds_count": len(thresholds),
        "thresholds": thresholds,
    }

    json_output_path = artifacts_dir / "thresholds_used.json"
    with open(json_output_path, "w") as f:
        json.dump(artifact, f, indent=2)

    print(f"Artifact written: {json_output_path}")

    # Summary
    print(f"\nGenerated {len(thresholds)} thresholds from {len(slos)} SLOs")

    for t in thresholds:
        status = "✓" if t.get("metric") not in ("custom", "unknown") else "○"
        print(f"  {status} {t['slo_id']}: {t.get('threshold_value', 'N/A')}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
